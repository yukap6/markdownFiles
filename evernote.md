正则引擎的分类
1. DFA
2. NFA

是否传统型 NFA？
> 用正则表达式 `/nfa|nfa not/` 来匹配字符串 `'nfa not'`，如果只有 `'nfa'` 匹配了，这就是传统型 NFA，如果整个 `'nfa not'` 都能匹配，则此引擎要么是 POSIX NFA，要么是 DFA。

DFA 还是 POSIX NFA？
> 用 `/X(.+)+X/` 来匹配 `'=XX======================================================='` 的字符串。
> 如果执行花很长时间，就是 NFA（如果上一项测试不是传统型 NFA，那就是 POSIX NFA）
> 如果时间很短，就是 DFA（或者是支持某些高级优化的 NFA）
> 如果是堆栈溢出，那就是 NFA 引擎

两条普适的原则
1. 优先选择最左端（最靠开头）的匹配结果
2. 标准的匹配量词（`?, *, +, {m, n}`）是匹配优先的

**传动装置和驱动过程**
> 传动装置的主要功能：驱动

**表达式主导与文本主导**
> NFA 表达式主导引擎（regex-directed）（汽油机）（非确定型有穷自动机）
> DFA 文本主导引擎（text-directed）（电动机）（确定型有穷自动机）

DFA 特征
1. DFA 匹配很迅速
2. DFA 匹配很一致
3. 谈论 DFA 匹配很恼人

**回溯（backtracking）**

* 用真实世界中的面包屑比喻回溯很恰当
* 回溯的原则：LIFO（last in first out）后进先出（用面包屑比喻就很好理解）
* 备用状态（saved state）：它们保存了两个位置，正则表达式中的位置和未尝试的分支在字符串中的位置

需要注意的是
1. 回溯机制不但需要计算正则表达式和文本的对应位置，也需要维护括号内字表达式所匹配的文本的状态
2. 由星号（或其他任何匹配优先量词）限定的部分不受后面元素影响，而只是匹配尽可能多的内容

> 通常情况下，忽略优先量词并不是排除类的完美替身，如下

```
var str = '<B>Billions</B> and <B>Zillions</B> of suns';
var str1 = '<B>Billions and <B> Zillions </B> of suns';
var reg = /<B>.*?<\/B>/;
str.match(reg); // <B>Billions</B>
str1.match(reg); // <B>Billions and <B> Zillions </B>
// 显然 str1.match(reg) 的匹配结果不是我们按照 Tag 匹配的目标结果

// 使用环视功能则可以做到
var reg1 = /<B>((?!<B>).)*?<\/B>/;
// 或者
var reg2 = /<B>((?!</?B>).)*<\/B>/;
```

正则表达式中的某个元素，无论是匹配优先还是忽略优先，都是为全局匹配服务的。

固化分组的影响
1. 毫无影响
2. 导致匹配失败
3. 改变匹配结果
4. 加快报告匹配失败的速度

`(?>.*?)` 会匹配什么？(P172)
> 它永远无法匹配任何字符

占有优先量词：`?+, *+, ++ 和 {m, n}+`
> 占有优先量词与匹配优先量词相似，只是他们从来不交还已经匹配的字符

